//! Contains code for safely parsing the DWARF .debug_line section

const std = @import("std");
const ArenaAllocator = std.heap.ArenaAllocator;
const ArrayList = std.ArrayList;
const ArrayListUnmanaged = std.ArrayListUnmanaged;
const assert = std.debug.assert;
const fs = std.fs;
const mem = std.mem;
const path = fs.path;
const pow = std.math.pow;
const t = std.testing;

const consts = @import("consts.zig");
const dwarf = @import("../dwarf.zig");
const file_util = @import("../../file.zig");
const info = @import("info.zig");
const logging = @import("../../logging.zig");
const Reader = @import("../../Reader.zig");
const safe = @import("../../safe.zig");
const test_data = @import("line_test.zig");
const trace = @import("../../trace.zig");
const types = @import("../../types.zig");

const log = logging.Logger.init(logging.Region.Symbols);

/// Like `types.SourceFile`, but with a mutable list of statements
pub const SourceFile = struct {
    hash: file_util.Hash,
    statements: ArrayListUnmanaged(types.SourceStatement) = .{},
};

/// Reads all information from the .debug_line section for this compile unit. Returned
/// memory is allocated in the scratch arena.
pub fn parse(
    opts: *dwarf.AttributeParseOpts,
    source_abs_path_hashes: *ArrayListUnmanaged(file_util.Hash),
    comp_dir: []const u8,
    line_offset: dwarf.Offset,
) dwarf.ParseError![]types.SourceFile {
    const z = trace.zoneN(@src(), "parse line");
    defer z.end();

    var r: Reader = undefined;
    r.init(opts.cu.opts.sections.line.contents[line_offset..]);

    const header = try Header.parse(opts, &r, comp_dir);
    for (header.file_paths.items) |abs_path| {
        // skip null entries and auto-generated files, but insert an entry to make sure indexes match
        if (abs_path.len == 0 or isAutogeneratedFile(abs_path)) {
            try source_abs_path_hashes.append(opts.cu.opts.scratch, 0);
            continue;
        }

        // save each hashed file path on the compile unit in the
        // correct order for later use during parsing
        const hash = opts.cu.opts.file_cache.add(abs_path) catch |err| switch (err) {
            error.InvalidPath => return error.InvalidDWARFInfo,
            else => |e| return e,
        };
        try source_abs_path_hashes.append(opts.cu.opts.scratch, hash);
    }

    const files = try parseLineEntries(opts, &r, header);

    // copy from line.SourceFile to types.SourceFile
    var res = try ArrayList(types.SourceFile).initCapacity(opts.cu.opts.scratch, files.items.len);
    for (files.items) |*f| res.appendAssumeCapacity(.{
        .file_hash = f.hash,
        .statements = try f.statements.toOwnedSlice(opts.cu.opts.scratch),
    });

    return res.toOwnedSlice();
}

fn parseLineEntries(
    opts: *const dwarf.AttributeParseOpts,
    r: *Reader,
    header: *Header,
) dwarf.ParseError!ArrayList(SourceFile) {
    const z = trace.zone(@src());
    defer z.end();

    var sources = ArrayList(SourceFile).init(opts.cu.opts.scratch);
    var entry = Entry{
        .is_stmt = header.default_is_stmt,
    };

    const max = pow(usize, 2, 24);
    for (0..max) |entry_ndx| {
        if (r.offset() >= header.unit_len) break;

        const opcode = try dwarf.read(r, u8);
        if (opcode >= header.opcode_base) {
            //
            // Special opcodes [DWARF4 6.2.5.1]
            //

            const adjusted_opcode = opcode - header.opcode_base;
            entry.advancePC(header, adjusted_opcode / header.line_range);

            const diff: i64 = adjusted_opcode % header.line_range;
            const delta_signed = header.line_base + diff;

            const delta = delta_signed;
            if (delta >= 0) {
                entry.line += @intCast(delta);
            } else {
                entry.line -= @abs(delta);
            }

            try entry.emit(opts, header, &sources);
        } else if (opcode == 0) {
            //
            // Extended opcodes [DWARF4 6.2.5.3]
            //

            const len = try dwarf.readULEB128(r);
            const start = r.offset();

            const ext_opcode = try dwarf.readEnum(r, u8, consts.LineTableExtendedOpcodes);
            switch (ext_opcode) {
                .padding => {},
                .end_sequence => {
                    // fully reset state
                    entry = Entry{
                        .is_stmt = header.default_is_stmt,
                        .end_sequence = true,
                    };
                },
                .set_address => {
                    entry.address = switch (header.addr_size) {
                        1 => try dwarf.read(r, u8),
                        2 => try dwarf.read(r, u16),
                        4 => try dwarf.read(r, u32),
                        8 => try dwarf.read(r, u64),
                        else => unreachable, // validated during header parse
                    };
                },
                .define_file => {
                    const file = try header.readFileEntry(r, opts);
                    if (file) |f| try header.file_paths.append(opts.cu.opts.scratch, f);

                    log.err("received null debug_line file entry");
                    return error.InvalidDWARFInfo;
                },
                .set_discriminator => entry.discriminator = try dwarf.readULEB128(r),

                else => {
                    log.errf("unsupported debug_line extended opcode: {s}", .{@tagName(ext_opcode)});
                    return error.InvalidDWARFInfo;
                },
            }

            const skip = start + len;
            r.seek(skip);
        } else {
            //
            // Standard opcodes [DWARF4 6.2.5.2]
            //

            const std_opcode = safe.enumFromInt(consts.LineTableStandardOpcodes, opcode) catch {
                return error.InvalidDWARFInfo;
            };

            switch (std_opcode) {
                .copy => try entry.emit(opts, header, &sources),
                .advance_pc => entry.advancePC(header, try dwarf.readULEB128(r)),
                .advance_line => {
                    const delta = try dwarf.readSLEB128(r);
                    if (delta >= 0) {
                        entry.line += @intCast(delta);
                    } else {
                        entry.line -= @abs(delta);
                    }
                },
                .set_file => entry.file = try dwarf.readULEB128(r),
                .set_column => entry.column = try dwarf.readULEB128(r),
                .negate_stmt => entry.is_stmt = !entry.is_stmt,
                .set_basic_block => entry.basic_block = true,
                .const_add_pc => entry.advancePC(header, (255 - header.opcode_base) / header.line_range),
                .fixed_advance_pc => {
                    // takes a uhalf, adds it to the addr register, and sets op_index to zero
                    // (ignores min_instruction_length)
                    const advance_by = try dwarf.read(r, u16);
                    entry.address += advance_by;
                    entry.op_index = 0;
                },
                .set_prologue_end => entry.prologue_end = true,
                .set_epilogue_begin => entry.epilogue_begin = true,
                .set_isa => entry.isa = try dwarf.readULEB128(r),
                .zig_set_decl => {},
            }
        }

        assert(entry_ndx < max - 1);
    }

    return sources;
}

const EntryFormat = struct {
    content_type: consts.LineTableContentType,
    form: consts.AttributeForm,
};

const Header = struct {
    const Self = @This();

    is_32_bit: bool = true,
    unit_len: u64 = 0,

    /// @TODO (jrc): use an enum rather than a u16
    version: u16 = 0,

    prologue_len: u64 = 0,
    min_instruction_len: u8 = 0,
    default_is_stmt: bool = false,
    line_base: i8 = 0,
    line_range: u8 = 0,
    opcode_base: u8 = 0,

    /// always are absolute paths
    include_dirs: ArrayListUnmanaged([]const u8) = .{},

    /// always are absolute paths
    file_paths: ArrayListUnmanaged([]const u8) = .{},

    //
    // new in v4
    //

    max_ops_per_instruction: u8 = 0,

    //
    // new in v5
    //

    addr_size: u8 = 0,
    segment_selector_size: u8 = 0,
    dir_entry_format_count: u8 = 0,
    dir_count: u64 = 0,
    dir_entry_formats: ArrayListUnmanaged(EntryFormat) = .{},
    file_entry_format_count: u8 = 0,
    file_count: u64 = 0,
    file_entry_formats: ArrayListUnmanaged(EntryFormat) = .{},

    fn parse(
        opts: *const dwarf.AttributeParseOpts,
        r: *Reader,
        comp_dir: []const u8,
    ) dwarf.ParseError!*Self {
        const z = trace.zoneN(@src(), "parse line table header");
        defer z.end();

        var self = try opts.cu.opts.scratch.create(Self);
        self.* = .{};

        self.unit_len = try dwarf.readInitialLength(r);
        self.is_32_bit = r.offset() == @sizeOf(u32);

        self.version = try dwarf.read(r, u16);
        if (self.version < 2 or self.version > 5) {
            log.errf("invalid line table version: {d}", .{self.version});
            return error.InvalidDWARFInfo;
        }

        if (self.version < 5) {
            self.addr_size = switch (self.is_32_bit) {
                true => 4,
                false => 8,
            };
        } else {
            self.addr_size = try dwarf.read(r, u8);
            switch (self.addr_size) {
                1, 2, 4, 8 => {}, // ok
                else => {
                    log.errf("invalid address size: {d}", .{self.addr_size});
                    return error.InvalidDWARFInfo;
                },
            }

            self.segment_selector_size = try dwarf.read(r, u8);
        }

        self.prologue_len = try self.readAddr(r);
        self.min_instruction_len = try dwarf.read(r, u8);

        if (self.version < 4) {
            self.max_ops_per_instruction = 1;
        } else {
            self.max_ops_per_instruction = try dwarf.read(r, u8);
        }

        self.default_is_stmt = (try dwarf.read(r, u8)) != 0;
        self.line_base = try dwarf.read(r, i8);
        self.line_range = try dwarf.read(r, u8);
        self.opcode_base = try dwarf.read(r, u8);
        if (self.opcode_base == 0) {
            log.err("opcode base must be greater than zero");
            return error.InvalidDWARFInfo;
        }

        // starts at ndx 1
        for (1..self.opcode_base) |_| {
            // read "standard opcode lengths", despite never needing to use them
            _ = try dwarf.read(r, u8);
        }

        if (self.version < 5) {
            //
            // Read the include directories table
            //

            const max = pow(usize, 2, 20);

            try self.include_dirs.append(opts.cu.opts.scratch, comp_dir);
            for (0..max) |dir_ndx| {
                var dir = try dwarf.readUntil(r, 0);
                if (dir.len == 0) break;

                // use the compile unit dir as the base for relateive paths
                if (!path.isAbsolute(dir)) {
                    dir = try path.join(opts.cu.opts.scratch, &[_][]const u8{ comp_dir, dir });
                }

                try self.include_dirs.append(opts.cu.opts.scratch, dir);

                assert(dir_ndx < max - 1);
            }

            //
            // Read the file name list
            //
            // @NOTE (jrc): DWARF v4 and below use a 1-indexed file entry table, so we intentionally add
            // a null entry at the start of the list to make keeping track of indexes less error-prone.
            // As of DWARF v5, the entries start at index 0.
            // @SRC: https://patchwork.sourceware.org/project/elfutils/patch/20240210025216.272034-1-amerey@redhat.com/#166361
            //

            try self.file_paths.append(opts.cu.opts.scratch, "");

            for (0..max) |file_ndx| {
                if (try self.readFileEntry(r, opts)) |file| {
                    try self.file_paths.append(opts.cu.opts.scratch, file);
                } else {
                    break;
                }

                assert(file_ndx < max - 1);
            }
        } else {
            {
                //
                // Read directories
                //

                self.dir_entry_format_count = try dwarf.read(r, u8);
                for (0..self.dir_entry_format_count) |_| {
                    try self.dir_entry_formats.append(opts.cu.opts.scratch, .{
                        .content_type = try dwarf.readEnumULEB128(r, consts.LineTableContentType),
                        .form = try dwarf.readEnumULEB128(r, consts.AttributeForm),
                    });
                }

                self.dir_count = try dwarf.readULEB128(r);
                for (0..self.dir_count) |_| {
                    var dir = try self.v5ReadLineFormat(opts, r, self.dir_entry_formats.items);

                    // use the compile unit dir as the base for relateive paths
                    if (!path.isAbsolute(dir)) {
                        dir = try path.join(opts.cu.opts.scratch, &[_][]const u8{ comp_dir, dir });
                    }

                    try self.include_dirs.append(opts.cu.opts.scratch, dir);
                }
            }

            {
                //
                // Read files
                //

                self.file_entry_format_count = try dwarf.read(r, u8);
                for (0..self.file_entry_format_count) |_| {
                    try self.file_entry_formats.append(opts.cu.opts.scratch, .{
                        .content_type = try dwarf.readEnumULEB128(r, consts.LineTableContentType),
                        .form = try dwarf.readEnumULEB128(r, consts.AttributeForm),
                    });
                }

                self.file_count = try dwarf.readULEB128(r);
                for (0..self.file_count) |_| {
                    const file = try self.v5ReadLineFormat(opts, r, self.file_entry_formats.items);
                    try self.file_paths.append(opts.cu.opts.scratch, file);
                }
            }
        }

        return self;
    }

    fn v5ReadLineFormat(
        self: *Self,
        opts: *const dwarf.AttributeParseOpts,
        r: *Reader,
        forms: []EntryFormat,
    ) dwarf.ParseError![]const u8 {
        const z = trace.zone(@src());
        defer z.end();

        var fpath: ?[]const u8 = null;
        var fdir: ?[]const u8 = null;

        for (forms) |form| {
            var str: ?[]const u8 = null;
            var val: ?u128 = null;

            switch (form.form) {
                .DW_FORM_string => str = try dwarf.readUntil(r, 0),

                .DW_FORM_strp, .DW_FORM_line_strp => {
                    const offset = try self.readAddr(r);
                    const section = switch (form.form) {
                        .DW_FORM_strp => opts.cu.opts.sections.str.contents,
                        .DW_FORM_line_strp => opts.cu.opts.sections.line_str.contents,
                        else => unreachable,
                    };

                    var str_r: Reader = undefined;
                    str_r.init(section);
                    str_r.seek(offset);
                    str = try dwarf.readUntil(&str_r, 0);
                },

                .DW_FORM_addr => val = try self.readAddr(r),

                .DW_FORM_data1 => val = try dwarf.read(r, u8),
                .DW_FORM_data2 => val = try dwarf.read(r, u16),
                .DW_FORM_data4 => val = try dwarf.read(r, u32),
                .DW_FORM_data8 => val = try dwarf.read(r, u64),
                .DW_FORM_data16 => val = try dwarf.read(r, u128),
                .DW_FORM_udata => val = try dwarf.readULEB128(r),

                else => {
                    log.errf("unsupported v5 line header form: {any} (content type: {any})", .{
                        form.form,
                        form.content_type,
                    });
                    return error.InvalidDWARFInfo;
                },
            }

            switch (form.content_type) {
                .path => {
                    if (str == null) {
                        log.err("v5 line header form path was null");
                        return error.InvalidDWARFInfo;
                    }
                    fpath = str.?;
                },

                .directory_ndx => {
                    if (val == null) {
                        log.err("v5 line header form value was null");
                        return error.InvalidDWARFInfo;
                    }

                    const ndx: usize = @intCast(val.?);
                    if (ndx >= self.include_dirs.items.len) {
                        log.err("v5 line header directory ndx out of range");
                        return error.InvalidDWARFInfo;
                    }

                    fdir = self.include_dirs.items[ndx];
                },

                else => {}, // ignore
            }
        }

        if (fpath == null) {
            log.err("v5 line header path not found");
            return error.InvalidDWARFInfo;
        }

        var file = fpath.?;
        if (fpath != null and fdir != null) {
            file = try path.join(
                opts.cu.opts.scratch,
                &[_][]const u8{ fdir.?, fpath.? },
            );
        }

        return file;
    }

    fn readFileEntry(self: *const Self, r: *Reader, opts: *const dwarf.AttributeParseOpts) dwarf.ParseError!?[]const u8 {
        const z = trace.zone(@src());
        defer z.end();

        var file = try dwarf.readUntil(r, 0);
        if (file.len == 0) return null;

        const dir_ndx = try dwarf.readULEB128(r);
        if (!path.isAbsolute(file)) {
            // look up the directory
            if (dir_ndx >= self.include_dirs.items.len) {
                log.errf("unable to find directory for relative file at ndx: {d}", .{dir_ndx});
                return error.InvalidDWARFInfo;
            }

            const dir = self.include_dirs.items[dir_ndx];
            file = try path.join(opts.cu.opts.scratch, &.{ dir, file });
        }

        // not needed
        _ = try dwarf.readULEB128(r); // mtime
        _ = try dwarf.readULEB128(r); // len

        return file;
    }

    fn readAddr(self: *Self, r: *Reader) !u64 {
        if (self.is_32_bit) return @intCast(try dwarf.read(r, u32));
        return try dwarf.read(r, u64);
    }

    test "parse zigloop line table header" {
        const zigloop = @embedFile("../test_files/linux_x86-64_zigloop_out_line");
        assert(zigloop.len > 0);

        const fc = try file_util.Cache.init(t.allocator);
        defer fc.deinit();

        var r: Reader = undefined;
        r.init(zigloop);

        var arena = ArenaAllocator.init(t.allocator);
        defer arena.deinit();
        const alloc = arena.allocator();

        const cu = try alloc.create(info.CompileUnit);
        cu.opts = &.{
            .scratch = alloc,
            .sections = undefined,
            .file_cache = fc,
        };
        const opts = &dwarf.AttributeParseOpts{ .cu = cu, .die = undefined };

        {
            //
            // Check the first compile unit's line table
            //

            // @NOTE (jrc): this does not actually attempt to look up a file at this location on the file system;
            // it only uses this path as the path for the directory in which the compile unit was originally built
            const h = try Header.parse(opts, &r, "/home/jcalabro/go/src/github.com/jcalabro/dbg/assets/zigloop");

            try t.expect(h.is_32_bit);
            try t.expectEqual(@as(u64, 171376), h.unit_len);
            try t.expectEqual(@as(u16, 4), h.version);
            try t.expectEqual(@as(u64, 1691), h.prologue_len);
            try t.expectEqual(@as(u8, 1), h.min_instruction_len);
            try t.expectEqual(@as(u8, 1), h.max_ops_per_instruction);
            try t.expect(h.default_is_stmt);
            try t.expectEqual(@as(i64, -5), h.line_base);
            try t.expectEqual(@as(u8, 14), h.line_range);
            try t.expectEqual(@as(u8, 13), h.opcode_base);

            try t.expectEqual(test_data.zigloop_dir_table.len, h.include_dirs.items.len);
            for (test_data.zigloop_dir_table, 0..) |dir, ndx| {
                try t.expectEqualSlices(u8, dir, h.include_dirs.items[ndx]);

                if (dir.len > 0) try t.expect(path.isAbsolute(dir));
            }

            for (test_data.zigloop_file_table, 0..) |file, ndx| {
                try t.expectEqualSlices(u8, file, h.file_paths.items[ndx]);

                if (file.len > 0) try t.expect(path.isAbsolute(file));
            }
        }
    }
};

const Entry = struct {
    const Self = @This();

    address: u64 = 0,
    op_index: u64 = 0,
    file: u64 = 1,
    line: u64 = 1,
    column: u64 = 0,
    is_stmt: bool,
    basic_block: bool = false,
    end_sequence: bool = false,
    prologue_end: bool = false,
    epilogue_begin: bool = false,
    isa: u64 = 0,
    discriminator: u64 = 0,

    /// internal field; not part of the dwarf standard
    prologue_len: u64 = 0,

    fn reset(self: *Self) void {
        self.basic_block = false;
        self.prologue_end = false;
        self.epilogue_begin = false;
        self.discriminator = 0;
    }

    /// Advances "operation pointer" (the combination of `address` and `op_index`) by N steps
    fn advancePC(self: *Self, header: *const Header, advance_by: u64) void {
        const op_index = @as(u64, self.op_index) + advance_by;
        self.address += header.min_instruction_len * (op_index / header.max_ops_per_instruction);
        self.op_index = op_index % @as(u64, header.max_ops_per_instruction);
    }

    fn emit(
        self: *Self,
        opts: *const dwarf.AttributeParseOpts,
        header: *const Header,
        sources: *ArrayList(SourceFile),
    ) dwarf.ParseError!void {
        const z = trace.zone(@src());
        defer z.end();

        if (self.file >= header.file_paths.items.len) {
            log.errf("unable to emit line entry: source file out of range (wanted {d}, got {d})", .{
                self.file,
                header.file_paths.items.len,
            });
            return error.InvalidDWARFInfo;
        }

        const abs_path = header.file_paths.items[self.file];

        // don't attempt to load auto-generated files (Go does a lot of this, esp. for CGO)
        if (isAutogeneratedFile(abs_path)) return;

        const src = blk: {
            const fhash = file_util.hashAbsPath(abs_path);

            // @PERFORMANCE (jrc): SIMD
            for (sources.items) |*s| {
                if (s.hash == fhash) {
                    break :blk s;
                }
            }

            const add_fhash = opts.cu.opts.file_cache.add(abs_path) catch |err| switch (err) {
                error.InvalidPath => return error.InvalidDWARFInfo,
                else => |e| return e,
            };
            assert(fhash == add_fhash);

            const s = try sources.addOne();
            s.* = .{ .hash = fhash };
            break :blk s;
        };

        if (self.prologue_end) {
            // If we're at the end of a prologue (PE), then we should
            // scan up the list of lines and remove any that are part
            // of the function prologue so the user doesn't hit them
            // when they're setting breakpoints and stepping.

            const num_statements: i64 = @intCast(src.statements.items.len);

            var ndx: i64 = 0;
            while (ndx < self.prologue_len) : (ndx += 1) {
                const stmt_ndx = num_statements - ndx - 1;
                if (stmt_ndx < 0) break;
                _ = src.statements.pop();
            }
        }

        if (self.epilogue_begin or self.prologue_end) {
            self.prologue_len = 0;
        } else {
            self.prologue_len += 1;
        }

        if (!self.epilogue_begin) {
            const skip = blk: {
                if (src.statements.items.len > 0) {
                    const prev = src.statements.items[src.statements.items.len - 1];
                    break :blk prev.line.int() == self.line;
                }
                break :blk false;
            };

            if (!skip) {
                try src.statements.append(opts.cu.opts.scratch, types.SourceStatement{
                    .breakpoint_addr = types.Address.from(self.address),
                    .line = types.SourceLine.from(self.line),
                });
            }
        }

        self.reset();
    }
};

fn isAutogeneratedFile(abs_path: []const u8) bool {
    return mem.endsWith(u8, abs_path, "<autogenerated>") or
        mem.endsWith(u8, abs_path, "_cgo_gotypes.go") or
        mem.count(u8, abs_path, "<missing>") > 0;
}
